<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake — Single File Game</title>
<style>
  :root{
    --bg:#0f1724;
    --panel: rgba(255,255,255,0.04);
    --accent:#00d1ff;
    --accent-2:#6affc1;
    --danger:#ff5c7c;
    --glass: rgba(255,255,255,0.06);
    --muted: rgba(255,255,255,0.6);
  }

  html,body{
    height:100%;
    margin:0;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg,#07111b 0%, #091827 60%), var(--bg);
    color:white;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .wrap{
    min-height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:28px;
    box-sizing:border-box;
    gap:24px;
  }

  .game-panel{
    background:var(--panel);
    border-radius:16px;
    padding:20px;
    box-shadow: 0 10px 30px rgba(2,6,23,0.6);
    display:flex;
    gap:18px;
    align-items:center;
    max-width:100%;
  }

  /* Canvas container */
  .canvas-wrap{
    position:relative;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px;
    padding:12px;
  }

  canvas{
    display:block;
    background:linear-gradient(180deg,#071b2a,#04202a);
    border-radius:8px;
    image-rendering: pixelated;
    width:480px;   /* CSS size — actual internal resolution is set in JS for crispness */
    height:480px;
    touch-action:none; /* allow swipe detection */
  }

  /* Sidebar */
  .ui{
    display:flex;
    flex-direction:column;
    gap:12px;
    min-width:180px;
  }

  .score{
    background:var(--glass);
    padding:10px 14px;
    border-radius:10px;
    text-align:center;
    box-shadow: inset 0 -2px 6px rgba(0,0,0,0.3);
  }
  .score h3{margin:0;font-size:13px;color:var(--muted);font-weight:600}
  .score p{margin:6px 0 0;font-size:28px;font-weight:700;color:var(--accent)}

  .controls{
    display:flex;
    flex-direction:column;
    gap:8px;
  }

  .btn{
    appearance:none;
    border:0;
    outline:0;
    cursor:pointer;
    padding:10px 12px;
    border-radius:10px;
    background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    color:white;
    font-weight:600;
    box-shadow: 0 6px 18px rgba(2,6,23,0.4);
    transition:transform .12s ease, box-shadow .12s;
  }
  .btn:active{ transform: translateY(1px) scale(.995); }
  .btn.primary{
    background: linear-gradient(90deg,var(--accent), var(--accent-2));
    color:#042127;
    box-shadow: 0 6px 22px rgba(0,209,255,0.12);
  }
  .muted{ font-size:13px; color:var(--muted); text-align:center; padding:8px; background:transparent; }

  .footer{
    font-size:12px;
    color:var(--muted);
    text-align:center;
  }

  /* overlay messages */
  .overlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
  }
  .panel-msg{
    pointer-events:auto;
    background:rgba(2,6,23,0.75);
    border-radius:10px;
    padding:18px 22px;
    text-align:center;
    box-shadow:0 6px 18px rgba(0,0,0,0.6);
  }
  .panel-msg h2{margin:0 0 8px;font-size:20px}
  .panel-msg p{margin:0 0 10px;color:var(--muted)}

  /* responsive */
  @media (max-width:900px){
    .game-panel{ flex-direction:column; align-items:center; }
    canvas{ width:360px; height:360px; }
    .ui{ min-width:unset; width:100%; display:flex; flex-direction:row; justify-content:space-between; }
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="game-panel">
    <div class="canvas-wrap" style="min-width:calc(480px + 24px);">
      <canvas id="game"></canvas>

      <!-- overlay for pause/gameover -->
      <div class="overlay" id="overlay" style="display:none">
        <div class="panel-msg" id="overlayPanel">
          <h2 id="overlayTitle">Paused</h2>
          <p id="overlayBody">Press Space or Click Resume</p>
          <div style="display:flex;gap:8px;justify-content:center;margin-top:10px">
            <button class="btn" id="resumeBtn">Resume</button>
            <button class="btn primary" id="restartBtn">Restart</button>
          </div>
        </div>
      </div>

    </div>

    <div class="ui">
      <div class="score">
        <h3>SCORE</h3>
        <p id="score">0</p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:10px">
          <div class="muted">High: <span id="high">0</span></div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="modeBtn">Mode: Wrap</button>
        <button class="btn primary" id="startBtn">Start Game</button>
        <button class="btn" id="pauseBtn">Pause</button>
        <button class="btn" id="speedBtn">Speed: <span id="speedVal">8</span></button>
        <div class="muted">Controls: Arrow keys or WASD. Swipe on touch.</div>
      </div>

      <div class="footer">
        <div>Classic Snake — single file</div>
        <div style="margin-top:8px"><button class="btn" id="resetHigh">Reset High Score</button></div>
      </div>
    </div>

  </div>
</div>

<script>

let wallMode = false; // false = wrap, true = wall is lethal

/*
  Single-file Snake game
  - grid-based
  - requestAnimationFrame with accumulator for speed control
  - arrow keys + WASD + swipe
  - persists high score in localStorage
*/

// ----- Config -----
const config = {
  gridSize: 20,     // number of cells per row/column
  baseSpeed: 8,     // moves per second
  maxFood: 1,
  canvasLogical: 480, // internal canvas resolution (square)
};

// ----- DOM -----
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highEl = document.getElementById('high');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayBody = document.getElementById('overlayBody');
const resumeBtn = document.getElementById('resumeBtn');
const restartBtn = document.getElementById('restartBtn');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const speedBtn = document.getElementById('speedBtn');
const speedVal = document.getElementById('speedVal');
const resetHighBtn = document.getElementById('resetHigh');

// scale canvas for crisp pixels
function fixCanvasSize(){
  // make canvas square logical resolution
  const cssWidth = canvas.clientWidth;
  const cssHeight = canvas.clientHeight;
  // use the smaller of css dims to set pixel density
  canvas.width = config.canvasLogical;
  canvas.height = config.canvasLogical;
  // we can scale drawing based on grid
}
fixCanvasSize();
window.addEventListener('resize', fixCanvasSize);

// ----- Game State -----
let snake, dir, nextDir, food, score, highScore, isRunning, isPaused;
let lastTime = 0;
let accumulator = 0;
let speed = config.baseSpeed; // moves per second

// load high score
highScore = Number(localStorage.getItem('snake_high') || 0);
highEl.textContent = highScore;

// initialize state
function resetGame(){
  const center = Math.floor(config.gridSize/2);
  snake = [
    {x:center+1, y:center},
    {x:center, y:center},
    {x:center-1, y:center},
  ];
  dir = {x:1,y:0}; // moving right
  nextDir = {x:1,y:0};
  spawnFood();
  score = 0;
  isRunning = false;
  isPaused = false;
  accumulator = 0;
  lastTime = 0;
  updateUI();
  hideOverlay();
}
resetGame();

// ----- Utilities -----
function randomCell(){
  return {
    x: Math.floor(Math.random()*config.gridSize),
    y: Math.floor(Math.random()*config.gridSize)
  };
}

function spawnFood(){
  // find a cell not occupied by snake
  let attempts = 0;
  do {
    food = randomCell();
    attempts++;
    if(attempts>1000) break;
  } while (snake.some(s => s.x === food.x && s.y === food.y));
}

// ----- Input -----
window.addEventListener('keydown', e=>{
  const key = e.key;
  if(key === 'ArrowUp' || key === 'w' || key === 'W'){
    setNextDir(0,-1);
  } else if(key === 'ArrowDown' || key === 's' || key === 'S'){
    setNextDir(0,1);
  } else if(key === 'ArrowLeft' || key === 'a' || key === 'A'){
    setNextDir(-1,0);
  } else if(key === 'ArrowRight' || key === 'd' || key === 'D'){
    setNextDir(1,0);
  } else if(key === ' '){ // space toggles pause/run
    togglePause();
  } else if(key === 'Enter'){
    if(!isRunning) startGame();
    else restart();
  }
});

function setNextDir(x,y){
  // prevent reversing directly
  if (dir.x === -x && dir.y === -y) return;
  nextDir = {x,y};
}

// Simple swipe detection for touch devices
let touchStart = null;
canvas.addEventListener('touchstart', (e)=>{
  if(e.touches && e.touches.length>0){
    const t = e.touches[0];
    touchStart = {x: t.clientX, y: t.clientY};
  }
});
canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchend', (e)=>{
  if(!touchStart) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStart.x;
  const dy = t.clientY - touchStart.y;
  const adx = Math.abs(dx), ady = Math.abs(dy);
  const threshold = 30;
  if(adx > ady && adx > threshold){
    if(dx > 0) setNextDir(1,0);
    else setNextDir(-1,0);
  } else if(ady > adx && ady > threshold){
    if(dy > 0) setNextDir(0,1);
    else setNextDir(0,-1);
  }
  touchStart = null;
});

// ----- Game Loop -----
function startGame(){
  if(isRunning) return;
  isRunning = true;
  isPaused = false;
  accumulator = 0;
  lastTime = performance.now();
  hideOverlay();
  requestAnimationFrame(loop);
}

function loop(now){
  if(!isRunning) return;
  const dt = (now - lastTime)/1000; // in seconds
  lastTime = now;
  accumulator += dt;

  const secondsPerMove = 1 / speed;

  while(accumulator >= secondsPerMove){
    accumulator -= secondsPerMove;
    step();
    if(!isRunning) break; // stop if game ended during step
  }

  render();
  if(isRunning && !isPaused) requestAnimationFrame(loop);
}

// step advances snake by one cell
function step(){
  // update direction
  dir = nextDir;

  const head = snake[0];
  const newHead = { x: head.x + dir.x, y: head.y + dir.y };

  // wrap-around on edges (classic variant); change to game over if you want collision with wall
if (wallMode) {
    // WALL MODE: die if snake hits wall
    if (
        newHead.x < 0 || newHead.x >= config.gridSize ||
        newHead.y < 0 || newHead.y >= config.gridSize
    ) {
        gameOver();
        return;
    }
} else {
    // WRAP MODE
    newHead.x = (newHead.x + config.gridSize) % config.gridSize;
    newHead.y = (newHead.y + config.gridSize) % config.gridSize;
}

  // collision with self?
  if (snake.some(s => s.x === newHead.x && s.y === newHead.y)){
    gameOver();
    return;
  }

  snake.unshift(newHead);

  // ate food?
  if (newHead.x === food.x && newHead.y === food.y){
    score += 10;
    spawnFood();
    updateUI();
  } else {
    snake.pop();
  }
}

// ----- Rendering -----
function render(){
  const size = canvas.width; // logical
  const cell = size / config.gridSize;

  // clear
  ctx.clearRect(0,0,size,size);

  // background subtle grid
  ctx.fillStyle = '#05141a';
  ctx.fillRect(0,0,size,size);

  // draw food (apple)
  ctx.fillStyle = '#ff6b6b';
  roundRect(ctx, food.x*cell + cell*0.12, food.y*cell + cell*0.12, cell*0.76, cell*0.76, cell*0.16);
  // little shine
  ctx.fillStyle = 'rgba(255,255,255,0.18)';
  ctx.fillRect(food.x*cell + cell*0.18, food.y*cell + cell*0.18, cell*0.18, cell*0.12);

  // draw snake - head with gradient
  for(let i=0;i<snake.length;i++){
    const s = snake[i];
    const px = s.x * cell;
    const py = s.y * cell;
    if(i===0){
      // head
      const g = ctx.createLinearGradient(px,py, px+cell, py+cell);
      g.addColorStop(0, '#00e4ff');
      g.addColorStop(1, '#00ffa0');
      ctx.fillStyle = g;
      roundRect(ctx, px + cell*0.08, py + cell*0.08, cell*0.84, cell*0.84, cell*0.14);
      // eye
      const eyeX = px + (dir.x === 1 ? cell*0.65 : dir.x === -1 ? cell*0.22 : cell*0.5) - cell*0.08;
      const eyeY = py + (dir.y === 1 ? cell*0.65 : dir.y === -1 ? cell*0.22 : cell*0.35);
      ctx.fillStyle = '#042127';
      ctx.beginPath();
      ctx.arc(eyeX, eyeY, cell*0.06, 0, Math.PI*2);
      ctx.fill();
    } else {
      // body
      // shade depending on index
      const t = i / Math.max(1, snake.length-1);
      ctx.fillStyle = `rgba(${Math.floor(0 + (0)*t)}, ${Math.floor(150 + (255-150)*t)}, ${Math.floor(160 + (255-160)*t)}, 1)`;
      roundRect(ctx, px + cell*0.12, py + cell*0.12, cell*0.76, cell*0.76, cell*0.12);
    }
  }

  // optional small grid lines
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for(let i=1;i<config.gridSize;i++){
    ctx.beginPath();
    ctx.moveTo(i*cell,0);
    ctx.lineTo(i*cell,size);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0,i*cell);
    ctx.lineTo(size,i*cell);
    ctx.stroke();
  }
}

function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
  ctx.fill();
}

// ----- Game Over / Pause -----
function gameOver(){
  isRunning = false;
  isPaused = false;
  showOverlay('Game Over', `Score: ${score}`);
  if(score > highScore){
    highScore = score;
    localStorage.setItem('snake_high', String(highScore));
    highEl.textContent = highScore;
  }
  updateUI();
}

function togglePause(){
  if(!isRunning) return;
  isPaused = !isPaused;
  if(isPaused){
    showOverlay('Paused', 'Press Space or Resume to continue');
  } else {
    hideOverlay();
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }
}

function showOverlay(title, body){
  overlayTitle.textContent = title;
  overlayBody.textContent = body;
  overlay.style.display = 'flex';
  overlay.style.pointerEvents = 'auto';
}

function hideOverlay(){
  overlay.style.display = 'none';
  overlay.style.pointerEvents = 'none';
}

// ----- UI handlers -----
resumeBtn.addEventListener('click', ()=>{ togglePause(); });
restartBtn.addEventListener('click', ()=>{ restart(); });
startBtn.addEventListener('click', ()=>{ startGame(); });
pauseBtn.addEventListener('click', ()=>{ togglePause(); });
speedBtn.addEventListener('click', ()=>{
  // cycle speeds
  const options = [6,8,10,12,14];
  const idx = options.indexOf(speed);
  const next = options[(idx+1) % options.length];
  speed = next;
  speedVal.textContent = speed;
  speedBtn.querySelector('span').textContent = speed;
});
resetHighBtn.addEventListener('click', ()=>{
  localStorage.removeItem('snake_high');
  highScore = 0;
  highEl.textContent = 0;
});
const modeBtn = document.getElementById('modeBtn');

modeBtn.addEventListener('click', () => {
  wallMode = !wallMode;
  modeBtn.textContent = "Mode: " + (wallMode ? "Wall" : "Wrap");
});

// restart keeps settings but resets the game
function restart(){
  resetGame();
  startGame();
}

// update UI bits
function updateUI(){
  scoreEl.textContent = score;
  highEl.textContent = highScore;
  speedVal.textContent = speed;
}

// update score reactively
const scoreObserver = new MutationObserver(()=>{/* no-op */});
scoreObserver.observe(scoreEl, {childList:true});

// update score after eating
(function scoreTicker(){
  const originalSpawnFood = spawnFood;
  spawnFood = function(){
    originalSpawnFood();
    // reflect immediately
    scoreEl.textContent = score;
  };
})();

// ensure initial render
render();

</script>
</body>
</html>